# -*- coding: utf-8 -*-
from math import ceil
from datetime import datetime

from models import pg_models
from models import redis_models
from sqlalchemy import desc
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import OperationalError

from models import mysql_models

from conf import judger_id

import json

MysqlSession = sessionmaker(bind=mysql_models.engine)
mysql_session = MysqlSession()  # 获得一个mysql会话？

PgSession = sessionmaker(bind=pg_models.engine)
pg_session = PgSession()  # 获得一个psql会话？


def get_problem_title(problem_id, test_data_id):  # 规范地按照问题ID和测试数据ID生成问题title。
    # 需要这个规范是因为sdustoj中的题目被按照测试数据分割成了hustoj中的N个题目。
    return 'sdustoj %s-%s' % (problem_id, test_data_id)


def update(**kwargs):
    global mysql_session, MysqlSession
    # 函数的作用是向hustoj数据库更新指定pid问题编号的测试数据和特殊评测信息。
    # 只是用来维护数据的。
    pid = kwargs['pid']
    # 以下查询全部位于psql数据库，也就是sdustoj数据库。
    test_data = pg_session.query(pg_models.TestData).join(
        pg_models.ProblemTestData, pg_models.TestData.id == pg_models.ProblemTestData.test_data_id
    ).filter_by(
        problem_id=pid, deleted=False
    ).all()
    # SELECT * FROM TestData WHERE problem_id==pid AND deleted<>FALSE
    # JOIN ProblemTestData ON TestData.id==ProblemTestData.test_data_id;
    # 从数据库中连接表TestData和ProblemTestData查询符合pid这个问题ID的条目。
    # 查询这个问题的测试数据集

    special_judge = pg_session.query(pg_models.SpecialJudge).filter_by(
        problem_id=pid, available=True, deleted=False).order_by(desc(pg_models.SpecialJudge.id)).first()
    # 查询这个问题的特殊评测，并且按特殊评测的id降序。

    limits = pg_session.query(pg_models.Limit).filter_by(problem_id=pid).all()
    # 查询编程限制。
    templates = {}
    makefiles = {}

    time_limit = 0
    memory_limit = 0
    for limit in limits:
        env = pg_session.query(pg_models.Environment).filter_by(id=limit.environment_id).first()
        if limit.is_temp:
            templates[env.judge_id] = json.dumps(limit.template_list)
        if limit.is_make:
            makefiles[env.judge_id] = limit.makefile
        if limit.time_limit > time_limit:
            time_limit = limit.time_limit
        if limit.memory_limit > memory_limit:
            memory_limit = limit.memory_limit
    # 这是……在所有限制里面取最大值的限制？

    problems = []  # 置入格式:(问题本体，测试数据，特殊评测)
    for data in test_data:  # 遍历一下测试数据集。
        p_title = get_problem_title(pid, data.id)  # 按照规范获得有关这组测试数据的title。
        try_remain = 1
        p = None
        while True:
            if try_remain <= 0:
                break
            try:
                p = mysql_session.query(mysql_models.Problem).filter_by(title=p_title).first()
                # 查询该题目是否已经在hustoj数据库中
            except OperationalError:
                # MySQL数据库因为长连接断开。重连一次。
                mysql_session = MysqlSession()
                p = None
            try_remain -= 1
            if p is not None:
                break
        if p is not None:  # 已存在状态，更新时间限制/空间限制/特殊评测，
            p.time_limit = ceil(time_limit / 1000)
            p.memory_limit = ceil(memory_limit / 1000)
            p.spj = '0' if special_judge is None else '1'
            problems.append((p, data, special_judge))  # 然后更新
        else:
            problem = mysql_models.Problem(  # 不存在就按照hustoj的模板创建一个题目，只填必要信息。
                title=p_title, description='Problem %s auto-generated by SDUSTOJ.' % (pid, ),
                input='', output='', sample_input='', sample_output='',
                spj='0' if special_judge is None else '1',
                hint='', source='SDUSTOJ',
                time_limit=ceil(time_limit / 1000), memory_limit=ceil(memory_limit / 1000)
            )
            mysql_session.add(problem)  # 看起来……这句是置入数据库。
            problems.append((problem, data, special_judge))  # 置入problems记录表。
    while True:
        try:
            flag = True
            mysql_session.commit()  # 提交对hustoj数据库的修改
        except OperationalError:
            mysql_session = MysqlSession()
            flag = False
        if flag is True:
            break

    judge = pg_session.query(pg_models.Judge).filter_by(id=judger_id).first()
    judge.last_update = datetime.now()
    pg_session.commit()
    # 上面的代码似乎是在更新sdustoj中这道题目的最后judge时间。那个Judge表的实际作用暂且不明。
    # todo 找个地方做temp和makefile的写入。
    for (p, t, s) in problems:
        redis_models.TestData.write(p.problem_id, t.test_in, t.test_out)  # 这句话调用到Client端，将测试数据写入Client文件系统。
        if s is not None:
            redis_models.SpecialJudge.write(p.problem_id, s.code)  # 将特殊评测写入。
        redis_models.Template.write(p.problem_id, **templates)
        redis_models.Makefile.write(p.problem_id, **makefiles)
        print('    Updated problem: ' + str(p.problem_id))


def update_meta(**kwargs):  # 更新指定题元的全部问题到hustoj数据库。
    mid = kwargs['mid']  # 这个简写貌似是题元ID的意思……
    problems = pg_session.query(pg_models.Problem).filter_by(deleted=False, meta_problem_id=mid).all()
    # 查询所有该题元下的题目
    for problem in problems:
        update(pid=problem.id)  # 更新所有的问题。


def update_all(**kwargs):  # 比较明确，更新全部sdustoj上存在的题目到hustoj数据库。
    if kwargs:
        kwargs.clear()
    meta_problems = pg_session.query(pg_models.MetaProblem).filter_by(deleted=False).all()
    for meta_problem in meta_problems:
        update_meta(mid=meta_problem.id)
